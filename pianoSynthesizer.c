/*
 * Lab8_5.c
 *Purpose: Making a Playable Keyboard
 * Created: 4/10/2023 9:24:14 PM
 * Author : Jonathan Lijewski
 */ 

#include <avr/io.h>
#include <avr/interrupt.h>
#include "usart.h"
#define BSEL     (33)
#define BSCALE   (-1)
extern void clock_init(void);
void DAC_INIT(void);
void TCC0_INIT(void);
void DMA_INIT(void);
void TCD0_INIT(void);
volatile float frequency = 1396.91;
volatile uint8_t timerReady = 0;
volatile uint8_t waveSwitch = 0;
volatile uint8_t charFound = 0;
volatile uint8_t charIndex = 0;
volatile uint8_t currChar = 0;
uint8_t keyboardChar;
void usartd0_inter();


uint16_t sine[256] =
{
	0x800,0x832,0x864,0x896,0x8c8,0x8fa,0x92c,0x95e,
	0x98f,0x9c0,0x9f1,0xa22,0xa52,0xa82,0xab1,0xae0,
	0xb0f,0xb3d,0xb6b,0xb98,0xbc5,0xbf1,0xc1c,0xc47,
	0xc71,0xc9a,0xcc3,0xceb,0xd12,0xd39,0xd5f,0xd83,
	0xda7,0xdca,0xded,0xe0e,0xe2e,0xe4e,0xe6c,0xe8a,
	0xea6,0xec1,0xedc,0xef5,0xf0d,0xf24,0xf3a,0xf4f,
	0xf63,0xf76,0xf87,0xf98,0xfa7,0xfb5,0xfc2,0xfcd,
	0xfd8,0xfe1,0xfe9,0xff0,0xff5,0xff9,0xffd,0xffe,
	0xfff,0xffe,0xffd,0xff9,0xff5,0xff0,0xfe9,0xfe1,
	0xfd8,0xfcd,0xfc2,0xfb5,0xfa7,0xf98,0xf87,0xf76,
	0xf63,0xf4f,0xf3a,0xf24,0xf0d,0xef5,0xedc,0xec1,
	0xea6,0xe8a,0xe6c,0xe4e,0xe2e,0xe0e,0xded,0xdca,
	0xda7,0xd83,0xd5f,0xd39,0xd12,0xceb,0xcc3,0xc9a,
	0xc71,0xc47,0xc1c,0xbf1,0xbc5,0xb98,0xb6b,0xb3d,
	0xb0f,0xae0,0xab1,0xa82,0xa52,0xa22,0x9f1,0x9c0,
	0x98f,0x95e,0x92c,0x8fa,0x8c8,0x896,0x864,0x832,
	0x800,0x7cd,0x79b,0x769,0x737,0x705,0x6d3,0x6a1,
	0x670,0x63f,0x60e,0x5dd,0x5ad,0x57d,0x54e,0x51f,
	0x4f0,0x4c2,0x494,0x467,0x43a,0x40e,0x3e3,0x3b8,
	0x38e,0x365,0x33c,0x314,0x2ed,0x2c6,0x2a0,0x27c,
	0x258,0x235,0x212,0x1f1,0x1d1,0x1b1,0x193,0x175,
	0x159,0x13e,0x123,0x10a,0xf2,0xdb,0xc5,0xb0,
	0x9c,0x89,0x78,0x67,0x58,0x4a,0x3d,0x32,
	0x27,0x1e,0x16,0xf,0xa,0x6,0x2,0x1,
	0x0,0x1,0x2,0x6,0xa,0xf,0x16,0x1e,
	0x27,0x32,0x3d,0x4a,0x58,0x67,0x78,0x89,
	0x9c,0xb0,0xc5,0xdb,0xf2,0x10a,0x123,0x13e,
	0x159,0x175,0x193,0x1b1,0x1d1,0x1f1,0x212,0x235,
	0x258,0x27c,0x2a0,0x2c6,0x2ed,0x314,0x33c,0x365,
	0x38e,0x3b8,0x3e3,0x40e,0x43a,0x467,0x494,0x4c2,
	0x4f0,0x51f,0x54e,0x57d,0x5ad,0x5dd,0x60e,0x63f,
	0x670,0x6a1,0x6d3,0x705,0x737,0x769,0x79b,0x7cd,
};
uint16_t decay[256] = 
{
	0x0,0x3f,0x7e,0xbc,0xf8,0x134,0x16e,0x1a8,
	0x1e1,0x219,0x250,0x287,0x2bc,0x2f1,0x325,0x358,
	0x38a,0x3bb,0x3ec,0x41c,0x44b,0x479,0x4a7,0x4d4,
	0x501,0x52c,0x557,0x581,0x5ab,0x5d4,0x5fc,0x624,
	0x64b,0x672,0x698,0x6bd,0x6e2,0x706,0x72a,0x74d,
	0x76f,0x791,0x7b3,0x7d3,0x7f4,0x814,0x833,0x852,
	0x871,0x88f,0x8ac,0x8c9,0x8e6,0x902,0x91e,0x939,
	0x954,0x96e,0x988,0x9a2,0x9bb,0x9d4,0x9ed,0xa05,
	0xa1d,0xa34,0xa4b,0xa62,0xa78,0xa8e,0xaa3,0xab9,
	0xace,0xae2,0xaf6,0xb0a,0xb1e,0xb31,0xb45,0xb57,
	0xb6a,0xb7c,0xb8e,0xb9f,0xbb1,0xbc2,0xbd3,0xbe3,
	0xbf4,0xc04,0xc13,0xc23,0xc32,0xc41,0xc50,0xc5f,
	0xc6d,0xc7b,0xc89,0xc97,0xca5,0xcb2,0xcbf,0xccc,
	0xcd9,0xce5,0xcf1,0xcfe,0xd0a,0xd15,0xd21,0xd2c,
	0xd37,0xd42,0xd4d,0xd58,0xd63,0xd6d,0xd77,0xd81,
	0xd8b,0xd95,0xd9e,0xda8,0xdb1,0xdba,0xdc3,0xdcc,
	0xdd5,0xddd,0xde6,0xdee,0xdf6,0xdfe,0xe06,0xe0e,
	0xe16,0xe1e,0xe25,0xe2c,0xe34,0xe3b,0xe42,0xe49,
	0xe4f,0xe56,0xe5d,0xe63,0xe6a,0xe70,0xe76,0xe7c,
	0xe82,0xe88,0xe8e,0xe94,0xe99,0xe9f,0xea4,0xeaa,
	0xeaf,0xeb4,0xeb9,0xebe,0xec3,0xec8,0xecd,0xed2,
	0xed6,0xedb,0xedf,0xee4,0xee8,0xeed,0xef1,0xef5,
	0xef9,0xefd,0xf01,0xf05,0xf09,0xf0d,0xf11,0xf14,
	0xf18,0xf1c,0xf1f,0xf23,0xf26,0xf29,0xf2d,0xf30,
	0xf33,0xf36,0xf39,0xf3c,0xf3f,0xf42,0xf45,0xf48,
	0xf4b,0xf4e,0xf51,0xf53,0xf56,0xf59,0xf5b,0xf5e,
	0xf60,0xf63,0xf65,0xf67,0xf6a,0xf6c,0xf6e,0xf71,
	0xf73,0xf75,0xf77,0xf79,0xf7b,0xf7d,0xf7f,0xf81,
	0xf83,0xf85,0xf87,0xf89,0xf8b,0xf8d,0xf8e,0xf90,
	0xf92,0xf94,0xf95,0xf97,0xf98,0xf9a,0xf9c,0xf9d,
	0xf9f,0xfa0,0xfa2,0xfa3,0xfa5,0xfa6,0xfa7,0xfa9,
	0xfaa,0xfab,0xfad,0xfae,0xfaf,0xfb0,0xfb2,0xfb3,
	};
char compKey[13] = 
{
	'e','4','r','5','t','y','7','u','8','i','9','o','p',
};
float frequencyTable[13] = 
{
	1046.50,1108.73,1174.66,1244.51,1318.51,1396.91,1479.98,1567.98,1661.22,1760.00,1864.66,1975.53,2093.00,
	};
int main(void)
{
	
	clock_init();
	usartd0_inter();
	DAC_INIT();
	DMA_INIT();
	
	
	
	
	PORTC.OUTSET = 0b10000000;
	PORTC.DIRSET = 0b10000000;
    /* Replace with your application code */
	//uint8_t index = 0;
    while (1) 
    {
		if(!(USARTD0.STATUS & USART_RXCIF_bm))
		{
			TCC0.CTRLA = TC_CLKSEL_OFF_gc;
		}
		else
		{
			keyboardChar = USARTD0_DATA;
			
			
				
			
			
			
			//while(!(USARTD0.STATUS & USART_RXCIF_bm));
			//USARTD0.STATUS = USART_RXCIF_bm;
			
			asm("nop");
			if(keyboardChar == 's')
			{
				waveSwitch = !waveSwitch; //change the array to either the sine or decay array
				DMA_INIT();
			}
			else
			{
				for(uint8_t i = 0; i<13; i++)
				{
					if(compKey[i] == keyboardChar)
					{
						charFound = 1;
						charIndex = i; // checks if the pressed key equals one of the chars in the array
						break;
					}
				}
				if(charFound)
				{
					charFound = 0;
					currChar = keyboardChar;
					frequency = frequencyTable[charIndex]; // set the timer frequency 
					asm("nop");
				
					if(USARTD0.STATUS & USART_RXCIF_bm)
					{
						asm("nop");
					}
				
					TCD0_INIT(); // start the delay counter
					TCC0_INIT(); // start playing the note
					
					while(!(TCD0.INTFLAGS & TC0_OVFIF_bm));
					TCD0.CTRLA = TC_CLKSEL_OFF_gc;
					TCD0.INTFLAGS = TC0_OVFIF_bm; // stop delay counter
					
					while(USARTD0.STATUS & USART_RXCIF_bm)
					{
						keyboardChar = USARTD0_DATA; // wait until key is no longer being pressed
					}
					
				
					//TCC0.CTRLA = TC_CLKSEL_OFF_gc;
				}
			
			}
			
		
		}
    }
}

void DAC_INIT(void)
{
	DACA.CTRLB = DAC_CHSEL_SINGLE1_gc | DAC_CH1TRIG_bm;//use only channel 0 of DAC and trigger events
	
	DACA.CTRLC = DAC_REFSEL_AREFB_gc; // use AREFB
	
	DACA.CTRLA = DAC_CH1EN_bm | DAC_ENABLE_bm; //enable channel 0 and the DAC module
	DACA.EVCTRL = DAC_EVSEL_0_gc;
	
} 
void TCC0_INIT(void)
{
	TCC0.CNT = 0;
	uint16_t periodValue = ((1/frequency)/256) * 32000000; // set the timer to overflow to a set frequency/256
	asm("nop");
	TCC0.PER = periodValue;
	
	
	TCC0.INTCTRLA |= TC_OVFINTLVL_MED_gc;
	
	PMIC_CTRL |= PMIC_MEDLVLEN_bm;
	
	sei();
	EVSYS.CH0MUX = EVSYS_CHMUX_TCC0_OVF_gc; // set the event system to trigger on timer overflow
	TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
	//EVSYS.CH1MUX = EVSYS_CHMUX_TCC0_OVF_gc;
}
/*ISR(TCC0_OVF_vect)
{
	//timerReady = 1;
	DMA.CH0.CTRLA |= DMA_CH_ENABLE_bm;
	DMA.CH0.CTRLA |= DMA_CH_TRFREQ_bm;
	
}*/
void DMA_INIT(void)
{
	DMA.CTRL = DMA_RESET_bm;
	
	//DMA.CH0.REPCNT = 0x00;
	
	DMA.CH0.CTRLA = DMA_CH_BURSTLEN_2BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm; //DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_REPEAT_bm | DMA_CH_SINGLE_bm;
	
	DMA.CH0.ADDRCTRL = DMA_CH_SRCRELOAD_BLOCK_gc | DMA_CH_SRCDIR_INC_gc | DMA_CH_DESTRELOAD_BURST_gc | DMA_CH_DESTDIR_INC_gc;
	
	DMA.CH0.TRIGSRC = DMA_CH_TRIGSRC_EVSYS_CH0_gc;
	
	DMA.CH0.TRFCNT = (uint16_t)(sizeof(sine));
	if (waveSwitch == 0) // if the waveSwitch is 0, set source to sine array, and when switch key is pressed, switch to decay array
	{
		DMA.CH0.SRCADDR0 = (uint8_t)((uintptr_t)sine);
		DMA.CH0.SRCADDR1 = (uint8_t)(((uintptr_t)sine)>>8);
		DMA.CH0.SRCADDR2 = (uint8_t)(((uint32_t)((uintptr_t)sine))>>16);
	}
	else
	{
		DMA.CH0.SRCADDR0 = (uint8_t)((uintptr_t)decay);
		DMA.CH0.SRCADDR1 = (uint8_t)(((uintptr_t)decay)>>8);
		DMA.CH0.SRCADDR2 = (uint8_t)(((uint32_t)((uintptr_t)decay))>>16);
	}
	
	
	DMA.CH0.DESTADDR0 = (uint8_t)((uintptr_t)&DACA.CH1DATAL);
	DMA.CH0.DESTADDR1 = (uint8_t)(((uintptr_t)&DACA.CH1DATAL)>>8);
	DMA.CH0.DESTADDR2 = (uint8_t)(((uint32_t)((uintptr_t)&DACA.CH1DATAL))>>16);
	
	DMA.CH0.CTRLA |= DMA_CH_ENABLE_bm;
	
	DMA.CTRL |= DMA_ENABLE_bm;
}
/*ISR(USARTD0_RXC_vect)
{
	char keyboardTest = USARTD0_DATA;
	asm("nop");
}*/
void usartd0_inter()
{
	/* Configure relevant TxD and RxD pins. */
	PORTD.OUTSET = PIN3_bm;
	PORTD.DIRSET = PIN3_bm;
	PORTD.DIRCLR = PIN2_bm;

  /* Configure baud rate. */
	USARTD0.BAUDCTRLA = (uint8_t)BSEL;
	USARTD0.BAUDCTRLB = (uint8_t)((BSCALE << 4)|(BSEL >> 8));

  /* Configure remainder of serial protocol. */
  /* (In this example, a protocol with 8 data bits, no parity, and
   *  one stop bit is chosen.) */
	USARTD0.CTRLC =	(USART_CMODE_ASYNCHRONOUS_gc |
					 USART_PMODE_ODD_gc  	 |
					 USART_CHSIZE_8BIT_gc)       &
					~USART_SBMODE_bm;

  /* Enable receiver and/or transmitter systems. */
	USARTD0.CTRLB = USART_RXEN_bm | USART_TXEN_bm;

  /* Enable interrupt (optional). */
	//USARTD0.CTRLA = USART_RXCINTLVL_MED_gc; 
	
	//PMIC_CTRL = PMIC_MEDLVLEN_bm;
	//sei();
}
void TCD0_INIT(void)
{
	TCD0.CNT = 0;
	uint16_t periodValue2 = (32000000*.2)/1024;
	asm("nop");
	TCD0.PER = periodValue2;
	TCD0.CTRLA = TC_CLKSEL_DIV1024_gc;
}